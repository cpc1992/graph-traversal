D3 is a js library for displaying data. It is hella complex and customizable.

These notes are specifically how to use it with react. 


------------------ Virtual DOM & why react and d3 dont play nice ---------------

First, Virtual DOM talk: DOM is a tree-like object representation of the webpage. the browser paints the DOM on the 
page. When DOM elements are updated, the browser must parse the HTML, remove the changed element, then replaces it 
with the new element, then updates layout and CSS. React uses a virtual DOM composed of two DOMs, 
it keeps a copy of the current DOM and creates an updated DOM. It then compares the two and takes note of what exactly changes.
After this it then updates the real with only the changes. It also does updates in batched. Its faster this way.

React and D3 have issues with each other because React uses a virtual DOM and D3 uses jquery to 
modify the real DOM. React will change the state of a component, and the state will cause the component to rerender.
But when D3 modifies the real DOM, React has no way of knowing that the real DOM has changed. Thus it's two copies of the virtual DOM become out of sync.
This can cause many bugs when react tries to updated the real DOM based on the difference between it's two virtual DOMs.

There are many solutions to this problem, in these notes we will be using a solution called: 

Lifecycle Methods Wrapping 

This solution involves creating our D3 code in a separate file, then creating a React wrapper component to contain it. 
Once we have it created, we will attach it, update it, and remove it using the react lifecycle methods.

here is a good blog: https://2019.wattenberger.com/blog/react-and-d3

----------------- Installing D3 ---------------------

-- create a react app, then in the folder enter:

npm i d3 

------------------ Notes on useRef hook ---------------------

-- D3 methods must be enacted on an HTML element. So for us to work with it in React, we will have to have some way to reference HTML elements in react. 
Enter the useRef hook.

import { useRef } from 'react'; 

-- useRef is used to create a reference to something. It can be a number, variable, or an html element. Its literally just a pointer to something. 
-- We can update our pointer to point to something and the component will not change. 
-- references are accessed by [variablename].current

-- It is most often used to reference an HTML element and is set upon initial render:

const h1Element = useRef(null)                        // 1. initialize to null

useEffect(() => {
    h1Element.current.innerText = "New home page"     // 3. the element is then accessed via h1Element.current       
},[])

return (
    <h1 ref={h1Element}> Home page </h1>               // 2. when the component renders, h1Element.current will point to this HTML element. 
)

Note: that useEffect occurs AFTER react renders the JSX (the stuff in the return).
The order in which these line occurs are:
1) Ref const h1Element is create and points to null
2) the return is called and the h1 is appended to the DOM. after being appended, ref constant h1Element points to it. 
3) the useEffect is called, and changes the inner text of the h1

------------------ Creating the wrapper for our D3 class ------------------

We will be creating a D3 class in a separete JS file. Then exporting that class. The class will take in an HTML element that we pass it.
The element will be enacted on by D3 to attach our D3 visuals. W


1) create a separate javascript file called D3Chart.js

    1a) import all methods from d3 into a d3 object at the top of your code: 

        import * as d3 from 'd3'; 

    1b) create/export a class called D3Chart. 

        class D3Chart{
            constructor(element){
                const svg = d3.select(element)        // in here we will enact our D3 functionality on the element passed to us. 
                        .append('svg')
                          .attr('width', 500)
                          .attr('height', 500);
                        
                svg.append('circle')
                     .attr('r', 40)
                     .attr('cy', 100)
                     .attr('cx', 100)
                     .attr('fill', 'red');
            }
        }

2) create a new react component called ChartWrapper and pop that guy into App.jsx like we do with any other React component.

    2a) create a reference to an element in the component with useRef, then on initial render, instantiate a new D3Chart() object and pass in the reference to the HTML element:

    function ChartWrapper() {
        const chart = useRef(null);

        useEffect(() => {
            new D3Chart(chart.current);               // create instance of D3Chart and pass in the referenced element 
        }, []);

        return (
            <>
            <h1>ChartWrapper</h1>
            <div ref={chart}></div>                   // create reference to the element that will hold our D3Chart
            </>
        );
    }

------------------ D3 data joining 101 ------------------
Good blog post on data(), enter(), update(), and exit()
https://bost.ocks.org/mike/join/

import * as d3 from 'd3'

-- we will use the d3 object's methods to select an element, and bind data to it, then append SVG elements 
to those bound data points. This allows us to customize the SVG element and do animations on the elements 
depending on the data bound to it. 

-- When we bind data to an element, d3 will compare the data to the data already bound to the element. It allows us to manipulate
any new data that we are binding, matching data that is already there, and old data that is not in the new updated bound data. 

data = [1,2,3,4,5,6]              // sample data

let svg = d3.select(element)      // this will find an element on the DOM and return it.   
    .append('svg')                // then we will append an svg element to it. => returns the appended element
      .attr('width', 1000)        // these are setting attributes of the svg element => return the element with the updated attribute
      .attr('height', 1000);

let selection = svg.selectAll('rect') // 1. now we are searching for all existing <rect> elements within the SVG element => returns a d3 selection. 
                                     // If you ran this previously, there may be some previously data-bound rect elements, THATs the point. on first run this will return an empty selection
   .data(data,                       // 2. This takes in an ARRAY of data and BINDS it to the selection. this returns a 3 part selection. enter, update, and exit. this line specifically returns the update section
   point => point);                  // this function is HOW THE DATA POINTS ARE COMPARED. if an existing point matches what this function returns, it is considered the "same point"
                                     // you can access the enter section by putting a .enter() same with exit(). 
                                     // enter represents the set of data that is new from the data you binded. 
                                     // update represent the set of data that you binded that already existed in the selection. 
                                     // exit represents the set of data that was already in the selection, but is not in the set of data you binded. 
                                     // its a venn diagram. you can alter each set of data seperately. => this returns the update() selection (bounded data that was already there that matches data you just binded)
    
selection.enter()                    // 3. we are now going to access the set of data that we binded that is all new. aka was not previously bound to the selection from line 1. => returns a selection 
   .append('rect')                   // 4. we are appending a rect svg element to each of the elements in the enter() selection. 
                                     // This will make rectangles appear on the screen representing all new data. => returns a selection of the newly added rect elements
     .attr('width', 50)              // 5. this will make all the of rect elements width 50 
     .attr('height', (d, i) => d)    // 6. this will dynamically set the height of each rect element based on the DATA POINT THAT IT IS BOUND TO. The second parameter can be a function, where 
                                     // the first parameter of the function is the data point that it is bound to. the second parameter is the data points index in the data array.
     .attr('x', (d, i) => 100 * i )  // 7. this will dynamically set the x coordinate offset of the svg element. aka it moves it right. every element will be 100 px to the right of the previous. 
     .attr('y', 20)                  // 8. this sets the y coordinate to 20 for all rect elements. 
     .attr('fill', 'green')          // set the color to green 

selection.exit()                     // 9. this is accessing the data exit selection aka the data that existed previously, but does not exist in the newly bound data. => returns a selection of already existing bound data 
   .remove()                         // 10. this will remove all of the old data from the svg. 

// this is how you do update() - you get it right out of the box (dont need to cal update())
selection                            // 11. this will access the data that already existed in the original selection THAT matches the data we bound to the selection. => returns a selection of elements that are already bound.
   .attr('fill', 'red')              // 12. this sets the color of the already existing elements to red.

-- essentially what we did was append a new set of data. all matching data that matches the newly bounds data turns red. any NEW data appears on the screen in green. and any already existing data that
does not match any point in the new data gets removed. 

------------------ D3 scales ------------------

-------- linear scale -- d3.scaleLinear(): this acts as a function (like y=mx+b) which takes in an input domain and converts it to an output range. 
To create the function we supply two things: 
1) a tuple array for the input domain
2) a tuple array for the output range. 
The linearScale() method will return a function that can take any number within the input domain and return to number scaled to the output domain. This is useful if we want to display a bar chart of people's 
heights, and we want to scale each bar to the max height of the bar chart. 

example: 
const y = d3.scaleLinear()
            .domain([0,300])        // the max range of heights that we will input to our chart if 282 cm.
            .range([0,500])         // but we want to scale the chart to 500 px.

console.log(y(150))                 // this will print 250. because 150 is half of 300 and scaled to 500 is 250. 

-- y acts as a formula or function that takes an input number (that is within the domain we set) and output thats number SCALED to the range that we provided. 
When we create our bar chart later, we use this to set the height of our bars when we append them to the page. 

const selection = d3.select(element)
              .append(svg)
              .attr('height', 500)                  // the height of the entire SVG is only 500 
              .attr('width', 500)
              .data(data)

selection.selectAll('rects')
         .enter()
         .append('rects')
         .attr('height', point => y(point.height))   // this way the bars are SCALED to the size of the SVG. if an input height comes in at 300 it will fill the entire height of the SVG. 
         .attr('width', 50)

-------- band scale -- d3.scaleBand(): this is a function that maps in input array of values to an output range. It returns a function that can take an input value (that must be in the input domain) and returns 
a number on in the output range scale. the output represents the start of the band that represents the value in the output range.

const x = d3.scaleBand()
            .domain(['a','b','c'])         // it basically takes the range 0 - 1000 and chops it into 3 bands (because there are 3 inputs). the first band is 'a', the second is 'b'...
            .range([0,1000])  

console.log(x('a'))                         // 0  
console.log(x('b'))                         // 333     it returns where the band for that input value starts on the range.
console.log(x('c'))                         // 666
console.log(x('d'))                         //undefined

-- you can add padding to it to make the bands look nicer: 

const x = d3.scaleBand()
            .domain(['a','b','c'])         
            .range([0,1000]) 
            .innerPadding(0.2)               // value from 0 to 1 that represents the space between each band. the scale is 0 to 1 STEPS which is from the start of one band to the start of the next
            .outerPadding(0.1)               // this will set the padding on the left and right of the starting and ending band

you can also just do padding(0.3) and it will set innerPadding and outerPadding to the same number 
 
-- When you use scaleBand, the width of the band will be calculated by the function that you created & other attributes like padding. To return this calculated value you can use bandwidth() method

x.bandwidth()       // will return the width of each band after applying your scale and padding and stuff.
x.scale()           // will return the distance between start of one band and the next. 

-------- note on how to specify domain 

When creating a scale, the input domain is based on the input data. 
For example in our linear scale, we specified the domain to be [0, 282]. We knew 282 is the height of the tallest person in the input data. But what if we don't know?

We need a way to find the max height or min height of the input data. D3 has a method for that. 

let max = d3.max(people, person => person.height)      // this is a method that takes 2 parms. the first is the input data array, the second is a function that returns the value to be compared
                                                       // this will return the max data_point.height in the data array.

let min = d3.min(grades, grade => grade.score)         // does the same but finds the minimum 

let minmax = d3.extent(people, person => person.age)  // this will return a TUPLE [18,75] which the first item is the minimum and the second is the max. 

-- it is common to use this in place of the domain variable 

let y = d3.scaleLinear()
          .domain([0, d3.max(data, p => p.height)])    // call it right in the domain funtion
          .range([0, height])

----

When inputting for a band scale, in which you need to input a set of values rather than a number tuple, it is recommended to use the map() function.
arr.map(p => p.height) iterates over every item in the array and returns a new array with only what is returned. 

for making bands, the input domain must be an array of values. so we can just call map when setting the domain variable:

let x = d3.scaleBand()
          .domain(data.map(point => point.name))     // call it right in the domain function. this will "name" every band that is created.
          .range([0, width])                         // use constants for your height and width to make it easily scalable.

------------------ Bars on the chart start at the top ------------------

the bars on the barchart seem to start at the top and grow downward...
-- the reason for this is that SVG 'rect's use the x and y attributes to determine location within the svg, except the x and y coordinates are the top left point of the rectangle.

To fix this we need to accomodate for this when we set our y attribute

d3.select('svg')
  .selectAll('rect')
  .data(data)
  .enter()
  .append('rect')
  .attr('x', point => x(point.name))
  .attr('y', point => height - y(point.height))     // we take the height (which can be variable), then minus the height of the bar - except we need to scale the height of the bar to the range first.
                                                    // this essentially will LOWER the top of the rectangle, and due to math the bottoms will align with the bottom of the SVG.
 
---------------- Adding Axis' to our chart ----------------

To add axis to an SVG can be very complicated. you would need to add a svg path and add tickes and text manually to it

D3 has an api to do it that makes it easier. It generates all the code for us, all we need to pass it is a scale (which we've already covered)

let axisGenerator = d3.axisTop(scale)         
let axisGenerator = d3.axisRight(scale)
let axisGenerator = d3.axisBottom(scale)      // creates a generator based on the scale we pass in with the ticks on the bottom
let axisGenerator = d3.axisLeft(scale)

svg.append('g').call(axisGenerator)           // attaches the axis to our SVG (draws the SVG paths to make the axis)

-- The top functions return an axis generator. After creating the generator we can connect it to our SVG via the .call() method. this will generate the axis SVG code. 
-- Top, Right, Bottom, Left indicate where the ticks and text are going to be. So if you want an axis on the left side, you want AxisLeft
-- AXIS must always be in their own group. so just append('g') before calling any generator.

How do we apply attributes to our axis?

-- we want to apply attributes to the GROUP of the axis. this is because the axis is made up of like 10 different svg elements. 
we need to apply the attribute change to the GROUP so it applies to all of them.

For example the x axis is still at the top of the screen. move it down by applying the transform translate attribute to the group:

svg.append('g')
.attr('transform', `translate(0, ${height})`)
.call(axisGenerator)

NOTE: there is a problem if we just stick this code in!!
The axis are literally placed at the top and bottom of the SVG, and the ticks are cut off. 
To fix this we must introduce margin.

---------------- Margin convention to fix axis problem ----------------

When we create a bar chart we should add margin to surrounding our chart so that ifno hanging off of our chart will be displayed on the screen.
Here is a good blog about this topic: https://gist.github.com/AdamMescher/d6f432d169743937f191cab778462d38

1) create a margin object with margin specified for top, bottom, left, and right

const margin = {top: 30, bottom: 30, right: 20, left: 20}

2) subtract the margin for the top and bottom from the height. and subtract the left and right from the width.
These are the variables used to define our SVG element.

let width = 800 - margin.left - margin.right;
let height = 500 - margin.top - margin.bottom;

3) BUT add them back in at creation time of the SVG. THEN append a group that has the transform attribute. 
This transform attribute will make it so that everything INSIDE OF IT IS SHIFTED DOWN AND RIGHT BY THE MARGIN.

let svg = d3.select(element)
            .append('svg')
              .attr('height', height + margin.top + margin.bottom)
              .attr('width', width + margin.left + margin.right)
            .append('g')                                                           // an SVG g element creates a GROUP. everything in this group gets the groups attributes applied to them
              .attr('transform', `translate(${margin.left}, ${margin.top})`)       // the transform attribute can be applied to any element. translate shifts the element by (x, y) amounts

---------------- Fix the y axis of the graph from showing backwards ----------------

The y axis on the left runs from our height scale to 0 going up (aka its backwards)
The reason it does this is that svg elements default run from top to bottom on the y axis. just like when initially put the bars in, they were stuck to the top and shot down.

We need to accomodate this by:

1) switch the output range on our y scale to the opposite - instead of 0 to height (500), we will now go from height (500) to 0. 
This is trippy think about it - the tallest person will have an input of like 250cm. after going through the y scale function, it will return 0. because we inverted the scale.

let y = scaleLinear()
        .domain([0, d3.max(data, data_point => data_point.height)])
        .range([height, 0])

-- you can think of it this way: now it does as it should, the range that is returned is now the distance from the TOP of our chart. so it effectively shows us the top of where our bar should be.

2) change the y attribute of our bars to just the y translated version of our height. (we had it like this before we adjusted them in the step called "Bars on the chart start at the top")
-- since we are now returning the distance from the top of the screen, we only need to shift it down by that much.

selection.enter()
        .append('rect')
        .attr('x', point => x(point.name))
        .attr('y', point => y(point.height)) // shift down by the distance the bar is from the top of the screen.

3) change the height attribute of our bars to be the entire screen minus the distance from the top 
-- this comes out to height - y(point.height)

selection.enter()
        .append('rect')
        .attr('x', point => x(point.name))
        .attr('y', point => y(point.height))
        .attr('width' x.bandwidth())
        .attr('height', point => height - y(point.height))

-- these three steps will alter the y axis to be starting at 0 and going up. and it also accomodates for our bars to be correct too.
It makes sense if you think about it. but if you are generating a barchart with axis, just do these three steps and dont think about it. 

NOTE: if you change the y scale domain starting number from 0 to a higher number, the y axis will only show from that number to the max, making the bars delta look more drastic.

---------------- how to add text to our SVG ---------------------
There is an svg element called text that you can add. to actually add the text you need to call the text() method to the element.
-- It can take a x and y attribute to place it correctly 

svg.append('text')
.attr('x', width/2)                 // this will center the text to the width of the SVG 
.attr('y', height)                  // put the text at the bottom of the screen
.text('The worlds tallest man')     // this actually add the text
.attr('text-anchor', 'middle')      // this changes the anchor of the text to the middle to help center text

-- if you run this without the last line, it will show the text on the screen except there is one problem:
we are putting the x value to be the width / 2 which ALMOST centers the text, except svg element by default
anchor themselves by the top left of the element. meaning the text will START at the middle of the screen. making it off center a little
-- to fix this there is an easy solution --> use the 'text-anchor' attribute. the 'middle' value will change the anchor to the middle of the text no matter how long it is 

NOTE: shapes default have their anchor in the middle

------ how to get the text to be sideways (like going UP the y axis)

-- you can add a transformation to rotate the text 90 degrees. 
DISCLAIMER: if you do this your x and y attributes will get flipped, depending on which way you rotate it.
-- I recommend just putting random nubmers or negative numbers in the x and y attributes to figure out which way each attribute moves the text.


svg.append('text')
    .attr('x', -height/2)                 // 2) we use negative height in the x attr now. 
    .attr('y', -35)                       // 2) i just tried different numbers here to get it to look right
    .text("Height in cm")
    .attr('text-anchor', 'middle')
    .attr('transform', 'rotate(-90)')     // 1) since we rotated it, the x and y get all messed up 

----------------- adding updates to our chart ---------------------
So generally we want to use the joining methods enter(), update(), and exit() to change the data. this requires that we have multiple sets of data to 
flick between. In this section we will do just that. 

In our chartwrapper class we first want to split every thing that is going to change into a different method called update()
-- this will include:
the bars - because obviously different data will have different heights 
the scale - because we are using the max height in the data to set the y scale. and we use the number of people in the data to set the x scale. 
the axis - because we use the scales to set the axis. NOTE remember that axis's are weird and need to be generated in a group. leave the group in the constructor and just put the call() in the update function

Thing that will stay in the constructor
-- the SVG itself and the big group to accomodate for margin will stay in the constructor. 
-- as will the text describing the axis's
-- and the group that the axis are generated in 
-- the data that is obtained from the API call. If theres multiple data sets then use promise.all()

HOW to connect the svg and stuff we created in the constructor to the update function?
-- Anything that we create in the constructor will be set as a property of the class, this way we can access it in the update() function without passing anything to it.
-- to set it as a class property we can use: this.svg = svg. or if you dont want to use the "this" key word:
const visualization = this;
visualization.svg = svg;
visualization.leftAxisGroup = visualization.avg.append('g')

//Call api
Promise.all(d3.json('https://example.com/data/1), d3.json('https://example.com/data/2'))        // call all apis
.then(dataset => {                                                                              // when the apis are all done dataset will be an array of the resolved data 
    visualization.data = dataset[0]                                                             // create a CLASS PROPERTY and set the data to it. (yes this is only setting it to the first one)
    visualization.update()                                                                      // call this classes update function to redraw the chart 

    // down here you can do some d3.interval stuff to flip between the data sets by
    // setting vis.data to dataset[1] then calling update again, or whatever algorithm you want
})

------------------ advanced D3 data joining 102 ------------------
--- GENERAL UPDATE PATTERN ---
Okay so when you append data to some seclection, obviously on the first run, you are appending a set of data to an empty selection. 
This results in ONLY the enter() function having nodes in it and they all need to be appended to the screen

But if there is existing data on the screen, then the selection will not be empty and you need to deal with update() and exit()

Wait... when you join a new set of data, how does d3 KNOW that this new data point matches up with this existing data point? 
1) if you call it just like this: 

selection.data(new_data)      // just pass the data to the selection

then d3 will match the data via INDEX IN THE ARRAY. This means the new data at slot 0 will be matched with the old data in slot 0, 1 to 1, 2 to 2, and etc
-- If the new data array has more slots that the old data array, then there will be data items in enter() that you will need to append onto the screen
-- if the is less new data than old data, then there will be data in exit() you will need to get rid of.

2) if you don't want to match up the data by its array index you can pass a function as a second parameter that returns HOW THE DATA WILL BE COMPARED

selection.data(new_data, p => p.name)       // a function is passed to the selection. it is called on every data item and d3 uses what it returns to match the data

-- now it will treat data with matching name as the same data point.

When you are dealing with update() and exit(), the nodes will initially exist "state" they were in before the data join. 
-- So in update(), the existing data nodes will have whatever x, y, height, width, fill attrbutes that they had when they were appended. 
-- if they need to move or change height/size based on their NEW height value, you will need to tell it to do that in the update() function 
    -- if you have a matching point in the first data set and the second data set, they you will need to MOVE HIM to where he is supposed to be when you join the second data set.
-- if you want items to transition in, then you need to add the transitions to the enter() function
-- if you want items to transition out, then you need to add the transtions to The exit() function

-------------------- transitions ----------------------

transitions are easy to add to data nodes. in any of the selection functions (enter update exit) you simply add a transition().duration(500)  <- the number is how many miliseconds it takes to go from the first state to the second
-- Everything BEFORE the transition().duration(n) call will be applied to the state of the data node IMMEDIATELY. 
-- Everything AFTER the transtion().duration(n) call will be applied to the node over the duration entered. 

1) At the time of an enter(), all attributes start at 0. so if you add a transtion to a rectangle on enter(), then put attr('height', 100) after the transition => this will make the rectangle transition 
from height 0 to height 100. making it pop up from the bottom/top of the screen.

selection.enter()
    .append('rect')
        .attr('x', p => x(p.name))              
        .attr('y', 0)  
        .attr('fill', 'green')  
        .attr('width', x.bandwidth()) 
        .attr('height', 0)                        // on enter(), we will append a rectangle and make its height 0 immediately
        .transition()                             // call transition
        .duration(500)
        .attr('height', p => p.height)            // over .5 seconds, it will transition to height of the data node, make it look like its growing from the ceiling.

2) At the time of an update(), all attributes will start at whatever "state" they were in after they entered the screen. So it is common to put a transition(), then change the location of the node so that it moves to where it
should go next depending on the data of the node. 

selection.attr('fill', 'blue')                    // if there are any existing nodes, immediately flash color them blue
    .transition()                                 // call transition
    .duration(500)
    .attr('x', p => x(p.name))                    // then over half a second move it to the spot in which is belongs in the new data set. 


3) at the time of an exit(), same as update(), nodes start with the attribute that they had when they were appended. 

selection.exit()
    .attr('fill', 'red')                           // exiting nodes will flash red
    .transition()
    .duration(500)
    .attr('height', 0)                             // then will shrink back into the ground over 500 ms.
    .attr('y', height)
    .remove()

bottom line: think of the state BEFORE the enter(), update(), exit().... then call transition... then think of the state you want it to be in after the transition.
NOTE: this all connects to HOW you are matching the new data up with the old data. think about that too (read prev section)

-------------------- transition our axis's

Axis's are weird and thus have a different way to transition them. its actually easier: 

just call transition before the call() function is made.

visualization.leftAxisGroup
    .transition()
    .duration(500)
    .call(leftAxisGenerator)

-- now when the axis is updated, the exit() text will fade out. update()text will shift to the correct location on the axis. and enter() text will fade in.

------------------- transition our text
Transitioning text when it changes is different from transitioning data nodes. 

in the constructor (never changes):

vis.title = vis.svg                             // create the text in the svg and put its location in the write spot
    .append('text')
    .attr('x', width / 2)
    .attr('y', height + 40)  
    .attr('text-anchor', 'middle')

in the update function (called whenever the data changes)

vis.title                                                                       // okay so this code will run every time update is called. 
    .transition()                                                               // whatever state it is currently in we will transition okay the below attributes over 250 ms
    .duration(250)
    .style("font-size",'0px')                                                   // font will change to size 0 over the transition time
    .transition()
    .duration(250)                                                              // now we got another transition that will happen after the first one
    .style("font-size",'18px')                                                  // font will change over the next 250 ms to 18 px
    .text(data == 'men' ? 'Worlds Tallest Men' : 'Worlds Tallest Women')        // note TEXT IS APPLIED IMMEDIATELY WHEN THIS TRANSTION GROUP HITS... it does not transition     <--- this is important

NOTE: this there is no enter, update, or exit. but this kinda simulates it

At FIRST render, there is NO TEXT. so the state of it when we hit the update function, is text =''. It then transitions to font size 0, but it is still invisible to us because trext = ''
Then the text is applied and text = 'World's Tallest Man' or whatever the data specifies. the text is applied immediately and will immediately flash in at the start of the transition.
one more time: text is not transitionable.
THEN the font will increase from 0 to 18 over the span of 250 ms.

On SECOND render, the text already exists stating 'Worlds Tallest Man'. Then it shrinks to font-size 0 over 250 ms. 
Then the text immediately changes to 'Worlds Tallest Women' in between transitions. 
Then the text will grow to 18px over the span of 250 ms.

------------------ switching data based on react button ---------------------
To connect the data to react state,

basic react stuff: 
1) create 2 button in the react app.js. These buttons will determine which data set we will visualize
2) the button will set the data state item to 'men' or 'women'
3) pass the data state item down to the Chartwrapper component as a prop. simple enough.

state things:
4) ChartWrapper component, on FIRST RENDER ONLY (useEffect with a [] dependency array) will create the D3Chart object. Then it will set the D3Chart as a state item
5) ChartWrapper component, on EVERY RERENDER EXCEPT THE FIRST when the data prop changes, will call D3Chart.update(data) to update the D3 object with the new data to visualize
    -- look below for how to do this

D3 class:
6) The D3 class will call the API to get the data in teh constructor, and immediately call update with the first set of data
7) The D3 class update function will take in data, and change the visualization based on the data passed. (data = 'men' or 'women')

NOTE: it is okay if the Chartwrapper component rerenders, because the d3 object is only created on first render and is stored in the state which persists through rerenders.

------------------ React thing: call this useEffect for every rerender but not the initial render -------------------

This is a react hook technique that mimics the react lifecycle ComponentDidUpdate 
-- It calls calls a function for every rerender, but does not call it for the first inital render

1) Create a useRef and set it to false
2) Create a useEffect that you want to update whenever some prop or something updates
3) In the useEffect, create a one time use latch that set the useRef to true instead of calling the real code you want. 
4) after setting the useRef to true, all renders after will call the code you want. 

const didMount = useRef(false);                      // didMount is initially set to false

useEffect(() => {
    if (didMount.current == false) {                 // if its false set it to true and do nothing else
        didMount.current = true;
    } else {                                      
        console.log(`displaying ${data} data`);      
        chart.update(data);                           // after the ref is set to true (burning the initial run) we will call the update function everytime after that
    }
}, [dataProp]);                                       // this will run every time the prop is changed.

-- the reason we use useRef is because you can change it without rerendering the entire component

----------------- transition delay --------------------
This is called "per element delay"

When we are displaying an array of data nodes like on the enter(), we can easily set the transition as they come in. They will all transition in within the the span of the transition time
But something fancy we can do it delay each node in the list by a certain milisecond to make the nodes appear in a wave like fashion. 

enter: .delay(func)

delay() takes in a function that will be run against every item in the data array. It must be applied to a TRANSITION. (to easily do this, just put it in between the transiton() and the duration())
-- the function we passed must return a number in miliseconds to delay all of the applied transitions by for that node. 

selection.enter()
    .append('rect')
    .attr('x', p => x(p.name))
    .attr('y', height)
    .attr('width', x.bandwidth())
    .attr('height', p => 0)
    .transition()
    .delay((d, i) => i*100)                      // this function will run on every data node in the array. And it will delay all transitions below this one by 100 ms depending on the slot in the array.
    .duration(500)
    .attr('y', p => y(p.height) - 1)
    .attr('height', p => height - y(p.height))

-- the bars in the above code will come in a like a wave
-- you can return a random number to allow for your bars to appear in a random order.

---------------- you can also use this to set a standard transition

.delay(2000)        // this will just delay the transtion by 2 seconds for all items.

---- other cool d3 functions: 
.each()    A function that can be paried with transitions. the function is called for every node ewither before the transition started or after the transtion has ended. look it up its kinda cool
.on()      you can use this for like on mouse over or mouse outs to change attributes like onHover effects
selection.append('title').text(d => d.height)    You can append a title element to an SVG element. Title text does not show up on the screen it is like metadata. BUT the cool thing is that when you HOVER OVER IT it shows the text as a tooltip.
    
