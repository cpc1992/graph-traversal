D3 is a js library for displaying data. It is hella complex and customizable.

These notes are specifically how to use it with react. 


------------------ Virtual DOM & why react and d3 dont play nice ---------------

First, Virtual DOM talk: DOM is a tree-like object representation of the webpage. the browser paints the DOM on the 
page. When DOM elements are updated, the browser must parse the HTML, remove the changed element, then replaces it 
with the new element, then updates layout and CSS. React uses a virtual DOM composed of two DOMs, 
it keeps a copy of the current DOM and creates an updated DOM. It then compares the two and takes note of what exactly changes.
After this it then updates the real with only the changes. It also does updates in batched. Its faster this way.

React and D3 have issues with each other because React uses a virtual DOM and D3 uses jquery to 
modify the real DOM. React will change the state of a component, and the state will cause the component to rerender.
But when D3 modifies the real DOM, React has no way of knowing that the real DOM has changed. Thus it's two copies of the virtual DOM become out of sync.
This can cause many bugs when react tries to updated the real DOM based on the difference between it's two virtual DOMs.

There are many solutions to this problem, in these notes we will be using a solution called: 

Lifecycle Methods Wrapping 

This solution involves creating our D3 code in a separate file, then creating a React wrapper component to contain it. 
Once we have it created, we will attach it, update it, and remove it using the react lifecycle methods.

here is a good blog: https://2019.wattenberger.com/blog/react-and-d3

----------------- Installing D3 ---------------------

-- create a react app, then in the folder enter:

npm i d3 

------------------ Notes on useRef hook ---------------------

-- D3 methods must be enacted on an HTML element. So for us to work with it in React, we will have to have some way to reference HTML elements in react. 
Enter the useRef hook.

import { useRef } from 'react'; 

-- useRef is used to create a reference to something. It can be a number, variable, or an html element. Its literally just a pointer to something. 
-- We can update our pointer to point to something and the component will not change. 
-- references are accessed by [variablename].current

-- It is most often used to reference an HTML element and is set upon initial render:

const h1Element = useRef(null)                        // 1. initialize to null

useEffect(() => {
    h1Element.current.innerText = "New home page"     // 3. the element is then accessed via h1Element.current       
},[])

return (
    <h1 ref={h1Element}> Home page </h1>               // 2. when the component renders, h1Element.current will point to this HTML element. 
)

Note: that useEffect occurs AFTER react renders the JSX (the stuff in the return).
The order in which these line occurs are:
1) Ref const h1Element is create and points to null
2) the return is called and the h1 is appended to the DOM. after being appended, ref constant h1Element points to it. 
3) the useEffect is called, and changes the inner text of the h1

------------------ Creating the wrapper for our D3 class ------------------

We will be creating a D3 class in a separete JS file. Then exporting that class. The class will take in an HTML element that we pass it.
The element will be enacted on by D3 to attach our D3 visuals. W


1) create a separate javascript file called D3Chart.js

    1a) import all methods from d3 into a d3 object at the top of your code: 

        import * as d3 from 'd3'; 

    1b) create/export a class called D3Chart. 

        class D3Chart{
            constructor(element){
                const svg = d3.select(element)        // in here we will enact our D3 functionality on the element passed to us. 
                        .append('svg')
                          .attr('width', 500)
                          .attr('height', 500);
                        
                svg.append('circle')
                     .attr('r', 40)
                     .attr('cy', 100)
                     .attr('cx', 100)
                     .attr('fill', 'red');
            }
        }

2) create a new react component called ChartWrapper and pop that guy into App.jsx like we do with any other React component.

    2a) create a reference to an element in the component with useRef, then on initial render, instantiate a new D3Chart() object and pass in the reference to the HTML element:

    function ChartWrapper() {
        const chart = useRef(null);

        useEffect(() => {
            new D3Chart(chart.current);               // create instance of D3Chart and pass in the referenced element 
        }, []);

        return (
            <>
            <h1>ChartWrapper</h1>
            <div ref={chart}></div>                   // create reference to the element that will hold our D3Chart
            </>
        );
    }

------------------ D3 data joining------------------
Good blog post on data(), enter(), update(), and exit()
https://bost.ocks.org/mike/join/

import * as d3 from 'd3'

-- we will use the d3 object's methods to select an element, and bind data to it, then append SVG elements 
to those bound data points. This allows us to customize the SVG element and do animations on the elements 
depending on the data bound to it. 

-- When we bind data to an element, d3 will compare the data to the data already bound to the element. It allows us to manipulate
any new data that we are binding, matching data that is already there, and old data that is not in the new updated bound data. 

data = [1,2,3,4,5,6]              // sample data

let svg = d3.select(element)      // this will find an element on the DOM and return it.   
    .append('svg')                // then we will append an svg element to it. => returns the appended element
      .attr('width', 1000)        // these are setting attributes of the svg element => return the element with the updated attribute
      .attr('height', 1000);

let selection = svg.selectAll('rect') // 1. now we are searching for all existing <rect> elements within the SVG element => returns a d3 selection. 
                                     // If you ran this previously, there may be some previously data-bound rect elements, THATs the point. on first run this will return an empty selection
   .data(data,                       // 2. This takes in an ARRAY of data and BINDS it to the selection. this returns a 3 part selection. enter, update, and exit. this line specifically returns the update section
   point => point);                  // this function is HOW THE DATA POINTS ARE COMPARED. if an existing point matches what this function returns, it is considered the "same point"
                                     // you can access the enter section by putting a .enter() same with exit(). 
                                     // enter represents the set of data that is new from the data you binded. 
                                     // update represent the set of data that you binded that already existed in the selection. 
                                     // exit represents the set of data that was already in the selection, but is not in the set of data you binded. 
                                     // its a venn diagram. you can alter each set of data seperately. => this returns the update() selection (bounded data that was already there that matches data you just binded)
    
selection.enter()                    // 3. we are now going to access the set of data that we binded that is all new. aka was not previously bound to the selection from line 1. => returns a selection 
   .append('rect')                   // 4. we are appending a rect svg element to each of the elements in the enter() selection. 
                                     // This will make rectangles appear on the screen representing all new data. => returns a selection of the newly added rect elements
     .attr('width', 50)              // 5. this will make all the of rect elements width 50 
     .attr('height', (d, i) => d)    // 6. this will dynamically set the height of each rect element based on the DATA POINT THAT IT IS BOUND TO. The second parameter can be a function, where 
                                     // the first parameter of the function is the data point that it is bound to. the second parameter is the data points index in the data array.
     .attr('x', (d, i) => 100 * i )  // 7. this will dynamically set the x coordinate offset of the svg element. aka it moves it right. every element will be 100 px to the right of the previous. 
     .attr('y', 20)                  // 8. this sets the y coordinate to 20 for all rect elements. 
     .attr('fill', 'green')          // set the color to green 

selection.exit()                     // 9. this is accessing the data exit selection aka the data that existed previously, but does not exist in the newly bound data. => returns a selection of already existing bound data 
   .remove()                         // 10. this will remove all of the old data from the svg. 

selection                            // 11. this will access the data that already existed in the original selection THAT matches the data we bound to the selection. => returns a selection of elements that are already bound.
   .attr('fill', 'red')              // 12. this sets the color of the already existing elements to red.

-- essentially what we did was append a new set of data. all matching data that matches the newly bounds data turns red. any NEW data appears on the screen in green. and any already existing data that
does not match any point in the new data gets removed. 

------------------ D3 scales ------------------

-------- linear scale -- d3.scaleLinear(): this acts as a function (like y=mx+b) which takes in an input domain and converts it to an output range. 
To create the function we supply two things: 
1) a tuple array for the input domain
2) a tuple array for the output range. 
The linearScale() method will return a function that can take any number within the input domain and return to number scaled to the output domain. This is useful if we want to display a bar chart of people's 
heights, and we want to scale each bar to the max height of the bar chart. 

example: 
const y = d3.scaleLinear()
            .domain([0,300])        // the max range of heights that we will input to our chart if 282 cm.
            .range([0,500])         // but we want to scale the chart to 500 px.

console.log(y(150))                 // this will print 250. because 150 is half of 300 and scaled to 500 is 250. 

-- y acts as a formula or function that takes an input number (that is within the domain we set) and output thats number SCALED to the range that we provided. 
When we create our bar chart later, we use this to set the height of our bars when we append them to the page. 

const selection = d3.select(element)
              .append(svg)
              .attr('height', 500)                  // the height of the entire SVG is only 500 
              .attr('width', 500)
              .data(data)

selection.selectAll('rects')
         .enter()
         .append('rects')
         .attr('height', point => y(point.height))   // this way the bars are SCALED to the size of the SVG. if an input height comes in at 300 it will fill the entire height of the SVG. 
         .attr('width', 50)

-------- band scale -- d3.scaleBand(): this is a function that maps in input array of values to an output range. It returns a function that can take an input value (that must be in the input domain) and returns 
a number on in the output range scale. the output represents the start of the band that represents the value in the output range.

const x = d3.scaleBand()
            .domain(['a','b','c'])         // it basically takes the range 0 - 1000 and chops it into 3 bands (because there are 3 inputs). the first band is 'a', the second is 'b'...
            .range([0,1000])  

console.log(x('a'))                         // 0  
console.log(x('b'))                         // 333     it returns where the band for that input value starts on the range.
console.log(x('c'))                         // 666
console.log(x('d'))                         //undefined

-- you can add padding to it to make the bands look nicer: 

const x = d3.scaleBand()
            .domain(['a','b','c'])         
            .range([0,1000]) 
            .innerPadding(0.2)               // value from 0 to 1 that represents the space between each band. the scale is 0 to 1 STEPS which is from the start of one band to the start of the next
            .outerPadding(0.1)               // this will set the padding on the left and right of the starting and ending band

you can also just do padding(0.3) and it will set innerPadding and outerPadding to the same number 
 
-- When you use scaleBand, the width of the band will be calculated by the function that you created & other attributes like padding. To return this calculated value you can use bandwidth() method

x.bandwidth()       // will return the width of each band after applying your scale and padding and stuff.
x.scale()           // will return the distance between start of one band and the next. 

-------- note on how to specify domain 

When creating a scale, the input domain is based on the input data. 
For example in our linear scale, we specified the domain to be [0, 282]. We knew 282 is the height of the tallest person in the input data. But what if we don't know?

We need a way to find the max height or min height of the input data. D3 has a method for that. 

let max = d3.max(people, person => person.height)      // this is a method that takes 2 parms. the first is the input data array, the second is a function that returns the value to be compared
                                                       // this will return the max data_point.height in the data array.

let min = d3.min(grades, grade => grade.score)         // does the same but finds the minimum 

let minmax = d3.extent(people, person => person.age)  // this will return a TUPLE [18,75] which the first item is the minimum and the second is the max. 

-- it is common to use this in place of the domain variable 

let y = d3.scaleLinear()
          .domain([0, d3.max(data, p => p.height)])    // call it right in the domain funtion
          .range([0, height])

----

When inputting for a band scale, in which you need to input a set of values rather than a number tuple, it is recommended to use the map() function.
arr.map(p => p.height) iterates over every item in the array and returns a new array with only what is returned. 

for making bands, the input domain must be an array of values. so we can just call map when setting the domain variable:

let x = d3.scaleBand()
          .domain(data.map(point => point.name))     // call it right in the domain function. this will "name" every band that is created.
          .range([0, width])                         // use constants for your height and width to make it easily scalable.

------------------ Bars on the chart start at the top ------------------

the bars on the barchart seem to start at the top and grow downward...
-- the reason for this is that SVG 'rect's use the x and y attributes to determine location within the svg, except the x and y coordinates are the top left point of the rectangle.

To fix this we need to accomodate for this when we set our y attribute

d3.select('svg')
  .selectAll('rect')
  .data(data)
  .enter()
  .append('rect')
  .attr('x', point => x(point.name))
  .attr('y', point => height - y(point.height))     // we take the height (which can be variable), then minus the height of the bar - except we need to scale the height of the bar to the range first.
                                                    // this essentially will LOWER the top of the rectangle, and due to math the bottoms will align with the bottom of the SVG.
 
---------------- Adding Axis' to our chart ----------------

To add axis to an SVG can be very complicated. you would need to add a svg path and add tickes and text manually to it

D3 has an api to do it that makes it easier. It generates all the code for us, all we need to pass it is a scale (which we've already covered)

let axisGenerator = d3.axisTop(scale)         
let axisGenerator = d3.axisRight(scale)
let axisGenerator = d3.axisBottom(scale)      // creates a generator based on the scale we pass in with the ticks on the bottom
let axisGenerator = d3.axisLeft(scale)

svg.append('g').call(axisGenerator)           // attaches the axis to our SVG (draws the SVG paths to make the axis)

-- The top functions return an axis generator. After creating the generator we can connect it to our SVG via the .call() method. this will generate the axis SVG code. 
-- Top, Right, Bottom, Left indicate where the ticks and text are going to be. So if you want an axis on the left side, you want AxisLeft
-- AXIS must always be in their own group. so just append('g') before calling any generator.

How do we apply attributes to our axis?

-- we want to apply attributes to the GROUP of the axis. this is because the axis is made up of like 10 different svg elements. 
we need to apply the attribute change to the GROUP so it applies to all of them.

For example the x axis is still at the top of the screen. move it down by applying the transform translate attribute to the group:

svg.append('g')
.attr('transform', `translate(0, ${height})`)
.call(axisGenerator)

NOTE: there is a problem if we just stick this code in!!
The axis are literally placed at the top and bottom of the SVG, and the ticks are cut off. 
To fix this we must introduce margin.

---------------- Margin convention to fix axis problem ----------------

When we create a bar chart we should add margin to surrounding our chart so that ifno hanging off of our chart will be displayed on the screen.
Here is a good blog about this topic: https://gist.github.com/AdamMescher/d6f432d169743937f191cab778462d38

1) create a margin object with margin specified for top, bottom, left, and right

const margin = {top: 30, bottom: 30, right: 20, left: 20}

2) subtract the margin for the top and bottom from the height. and subtract the left and right from the width.
These are the variables used to define our SVG element.

let width = 800 - margin.left - margin.right;
let height = 500 - margin.top - margin.bottom;

3) BUT add them back in at creation time of the SVG. THEN append a group that has the transform attribute. 
This transform attribute will make it so that everything INSIDE OF IT IS SHIFTED DOWN AND RIGHT BY THE MARGIN.

let svg = d3.select(element)
            .append('svg')
              .attr('height', height + margin.top + margin.bottom)
              .attr('width', width + margin.left + margin.right)
            .append('g')                                                           // an SVG g element creates a GROUP. everything in this group gets the groups attributes applied to them
              .attr('transform', `translate(${margin.left}, ${margin.top})`)       // the transform attribute can be applied to any element. translate shifts the element by (x, y) amounts

---------------- Fix the y axis of the graph from showing backwards ----------------

The y axis on the left runs from our height scale to 0 going up (aka its backwards)
The reason it does this is that svg elements default run from top to bottom on the y axis. just like when initially put the bars in, they were stuck to the top and shot down.

We need to accomodate this by:

1) switch the output range on our y scale to the opposite - instead of 0 to height (500), we will now go from height (500) to 0. 
This is trippy think about it - the tallest person will have an input of like 250cm. after going through the y scale function, it will return 0. because we inverted the scale.

let y = scaleLinear()
        .domain([0, d3.max(data, data_point => data_point.height)])
        .range([height, 0])

-- you can think of it this way: now it does as it should, the range that is returned is now the distance from the TOP of our chart. so it effectively shows us the top of where our bar should be.

2) change the y attribute of our bars to just the y translated version of our height. (we had it like this before we adjusted them in the step called "Bars on the chart start at the top")
-- since we are now returning the distance from the top of the screen, we only need to shift it down by that much.

selection.enter()
        .append('rect')
        .attr('x', point => x(point.name))
        .attr('y', point => y(point.height)) // shift down by the distance the bar is from the top of the screen.

3) change the height attribute of our bars to be the entire screen minus the distance from the top 
-- this comes out to height - y(point.height)

selection.enter()
        .append('rect')
        .attr('x', point => x(point.name))
        .attr('y', point => y(point.height))
        .attr('width' x.bandwidth())
        .attr('height', point => height - y(point.height))

-- these three steps will alter the y axis to be starting at 0 and going up. and it also accomodates for our bars to be correct too.
It makes sense if you think about it. but if you are generating a barchart with axis, just do these three steps and dont think about it. 

NOTE: if you change the y scale domain starting number from 0 to a higher number, the y axis will only show from that number to the max, making the bars delta look more drastic.

---------------- how to add text to our SVG ---------------------
There is an svg element called text that you can add. to actually add the text you need to call the text() method to the element.
-- It can take a x and y attribute to place it correctly 

svg.append('text')
.attr('x', width/2)                 // this will center the text to the width of the SVG 
.attr('y', height)                  // put the text at the bottom of the screen
.text('The worlds tallest man')     // this actually add the text
.attr('text-anchor', 'middle')      // this changes the anchor of the text to the middle to help center text

-- if you run this without the last line, it will show the text on the screen except there is one problem:
we are putting the x value to be the width / 2 which ALMOST centers the text, except svg element by default
anchor themselves by the top left of the element. meaning the text will START at the middle of the screen. making it off center a little
-- to fix this there is an easy solution --> use the 'text-anchor' attribute. the 'middle' value will change the anchor to the middle of the text no matter how long it is 

NOTE: shapes default have their anchor in the middle

------ how to get the text to be sideways (like going UP the y axis)

-- you can add a transformation to rotate the text 90 degrees. 
DISCLAIMER: if you do this your x and y attributes will get flipped, depending on which way you rotate it.
-- I recommend just putting random nubmers or negative numbers in the x and y attributes to figure out which way each attribute moves the text.


svg.append('text')
    .attr('x', -height/2)                 // 2) we use negative height in the x attr now. 
    .attr('y', -35)                       // 2) i just tried different numbers here to get it to look right
    .text("Height in cm")
    .attr('text-anchor', 'middle')
    .attr('transform', 'rotate(-90)')     // 1) since we rotated it, the x and y get all messed up 

----------------- adding updates to our chart ---------------------
So generally we want to use the joining methods enter(), update(), and exit() to change the data. this requires that we have multiple sets of data to 
flick between. In this section we will do just that. 

In our chartwrapper class we first want to split every thing that is going to change into a different method called update()
-- this will include:
the bars - because obviously different data will have different heights 
the scale - because we are using the max height in the data to set the y scale. and we use the number of people in the data to set the x scale. 
the axis - because we use the scales to set the axis. 

-- the SVG itself and the big group to accomodate for margin will stay in the constructor. 
-- as will the text describing the axis'

update(){

}