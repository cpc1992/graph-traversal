D3 is a js library for displaying data. It is hella complex and customizable.

These notes are specifically how to use it with react. 


------------------ Virtual DOM & why react and d3 dont play nice ---------------

First, Virtual DOM talk: DOM is a tree-like object representation of the webpage. the browser paints the DOM on the 
page. When DOM elements are updated, the browser must parse the HTML, remove the changed element, then replaces it 
with the new element, then updates layout and CSS. React uses a virtual DOM composed of two DOMs, 
it keeps a copy of the current DOM and creates an updated DOM. It then compares the two and takes note of what exactly changes.
After this it then updates the real with only the changes. It also does updates in batched. Its faster this way.

React and D3 have issues with each other because React uses a virtual DOM and D3 uses jquery to 
modify the real DOM. React will change the state of a component, and the state will cause the component to rerender.
But when D3 modifies the real DOM, React has no way of knowing that the real DOM has changed. Thus it's two copies of the virtual DOM become out of sync.
This can cause many bugs when react tries to updated the real DOM based on the difference between it's two virtual DOMs.

There are many solutions to this problem, in these notes we will be using a solution called: 

Lifecycle Methods Wrapping 

This solution involves creating our D3 code in a separate file, then creating a React wrapper component to contain it. 
Once we have it created, we will attach it, update it, and remove it using the react lifecycle methods.

here is a good blog: https://2019.wattenberger.com/blog/react-and-d3

----------------- Installing D3 ---------------------

-- create a react app, then in the folder enter:

npm i d3 

------------------ Notes on useRef hook ---------------------

-- D3 methods must be enacted on an HTML element. So for us to work with it in React, we will have to have some way to reference HTML elements in react. 
Enter the useRef hook.

import { useRef } from 'react'; 

-- useRef is used to create a reference to something. It can be a number, variable, or an html element. Its literally just a pointer to something. 
-- We can update our pointer to point to something and the component will not change. 
-- references are accessed by [variablename].current

-- It is most often used to reference an HTML element and is set upon initial render:

const h1Element = useRef(null)                        // 1. initialize to null

useEffect(() => {
    h1Element.current.innerText = "New home page"     // 3. the element is then accessed via h1Element.current       
},[])

return (
    <h1 ref={h1Element}> Home page </h1>               // 2. when the component renders, h1Element.current will point to this HTML element. 
)

Note: that useEffect occurs AFTER react renders the JSX (the stuff in the return).

------------------ Creating the wrapper for our D3 class ------------------

We will be creating a D3 class in a separete JS file. Then exporting that class. The class will take in an HTML element that we pass it.
The element will be enacted on by D3 to attach our D3 visuals. W


1) create a separate javascript file called D3Chart.js

    1a) import all methods from d3 into a d3 object at the top of your code: 

        import * as d3 from 'd3'; 

    1b) create/export a class called D3Chart. 

        class D3Chart{
            constructor(element){
                const svg = d3.select(element)        // in here we will enact our D3 functionality on the element passed to us. 
                        .append('svg')
                          .attr('width', 500)
                          .attr('height', 500);
                        
                svg.append('circle')
                     .attr('r', 40)
                     .attr('cy', 100)
                     .attr('cx', 100)
                     .attr('fill', 'red');
            }
        }

2) create a new react component called ChartWrapper and pop that guy into App.jsx like we do with any other React component.

    2a) create a reference to an element in the component with useRef, then on initial render, instantiate a new D3Chart() object and pass in the reference to the HTML element:

    function ChartWrapper() {
        const chart = useRef(null);

        useEffect(() => {
            new D3Chart(chart.current);               // create instance of D3Chart and pass in the referenced element 
        }, []);

        return (
            <>
            <h1>ChartWrapper</h1>
            <div ref={chart}></div>                   // create reference to the element that will hold our D3Chart
            </>
        );
    }

------------------ D3 ------------------
Good blog post on data(), enter(), update(), and exit()
https://bost.ocks.org/mike/join/

import * as d3 from 'd3'

-- we will use the d3 object's methods to select an element, and bind data to it, then append SVG elements 
to those bound data points. This allows us to customize the SVG element and do animations on the elements 
depending on the data bound to it. 

-- When we bind data to an element, d3 will compare the data to the data already bound to the element. It allows us to manipulate
any new data that we are binding, matching data that is already there, and old data that is not in the new updated bound data. 

data = [1,2,3,4,5,6]              // sample data

let svg = d3.select(element)      // this will find an element on the DOM and return it.   
    .append('svg')                // then we will append an svg element to it. => returns the appended element
      .attr('width', 1000)        // these are setting attributes of the svg element => return the element with the updated attribute
      .attr('height', 1000);

let selection = svg.selectAll('rect') // 1. now we are searching for all existing <rect> elements within the SVG element => returns a d3 selection. 
                                     // If you ran this previously, there may be some previously data-bound rect elements, THATs the point. on first run this will return an empty selection
   .data(data);                      // 2. This takes in an ARRAY of data and BINDS it to the selection. this returns a 3 part selection. enter, update, and exit. this line specifically returns the update section
                                     // you can access the enter section by putting a .enter() same with exit(). 
                                     // enter represents the set of data that is new from the data you binded. 
                                     // update represent the set of data that you binded that already existed in the selection. 
                                     // exit represents the set of data that was already in the selection, but is not in the set of data you binded. 
                                     // its a venn diagram. you can alter each set of data seperately. => this returns the update() selection (bounded data that was already there that matches data you just binded)
    
selection.enter()                    // 3. we are now going to access the set of data that we binded that is all new. aka was not previously bound to the selection from line 1. => returns a selection 
   .append('rect')                   // 4. we are appending a rect svg element to each of the elements in the enter() selection. 
                                     // This will make rectangles appear on the screen representing all new data. => returns a selection of the newly added rect elements
     .attr('width', 50)              // 5. this will make all the of rect elements width 50 
     .attr('height', (d, i) => d)    // 6. this will dynamically set the height of each rect element based on the DATA POINT THAT IT IS BOUND TO. The second parameter can be a function, where 
                                     // the first parameter of the function is the data point that it is bound to. the second parameter is the data points index in the data array.
     .attr('x', (d, i) => 100 * i )  // 7. this will dynamically set the x coordinate offset of the svg element. aka it moves it right. every element will be 100 px to the right of the previous. 
     .attr('y', 20)                  // 8. this sets the y coordinate to 20 for all rect elements. 
     .attr('fill', 'green')          // set the color to green 

selection.exit()                     // 9. this is accessing the data exit selection aka the data that existed previously, but does not exist in the newly bound data. => returns a selection of already existing bound data 
   .remove()                         // 10. this will remove all of the old data from the svg. 

selection.update()                   // 11. this will access the data that already existed in the original selection THAT matches the data we bound to the selection. => returns a selection of elements that are already bound.
   .attr('fill', 'red')              // 12. this sets the color of the already existing elements to red.

-- essentially what we did was append a new set of data. all matching data that matches the newly bounds data turns red. any NEW data appears on the screen in green. and any already existing data that
does not match any point in the new data gets removed. 
