D3 is a js library for displaying data. It is hella complex and customizable.

These notes are specifically how to use it with react. 


------------------ Virtual DOM & why react and d3 dont play nice ---------------

First, Virtual DOM talk: DOM is a tree-like object representation of the webpage. the browser paints the DOM on the 
page. When DOM elements are updated, the browser must parse the HTML, remove the changed element, then replaces it 
with the new element, then updates layout and CSS. React uses a virtual DOM composed of two DOMs, 
it keeps a copy of the current DOM and creates an updated DOM. It then compares the two and takes note of what exactly changes.
After this it then updates the real with only the changes. It also does updates in batched. Its faster this way.

React and D3 have issues with each other because React uses a virtual DOM and D3 uses jquery to 
modify the real DOM. React will change the state of a component, and the state will cause the component to rerender.
But when D3 modifies the real DOM, React has no way of knowing that the real DOM has changed. Thus it's two copies of the virtual DOM become out of sync.
This can cause many bugs when react tries to updated the real DOM based on the difference between it's two virtual DOMs.

There are many solutions to this problem, in these notes we will be using a solution called: 

Lifecycle Methods Wrapping 

This solution involves creating our D3 code in a separate file, then creating a React wrapper component to contain it. 
Once we have it created, we will attach it, update it, and remove it using the react lifecycle methods.

here is a good blog: https://2019.wattenberger.com/blog/react-and-d3

----------------- Installing D3 ---------------------

-- create a react app, then in the folder enter:

npm i d3 

------------------ Notes on useRef hook ---------------------

-- D3 methods must be enacted on an HTML element. So for us to work with it in React, we will have to have some way to reference HTML elements in react. 
Enter the useRef hook.

import { useRef } from 'react'; 

-- useRef is used to create a reference to something. It can be a number, variable, or an html element. Its literally just a pointer to something. 
-- We can update our pointer to point to something and the component will not change. 
-- references are accessed by [variablename].current

-- It is most often used to reference an HTML element and is set upon initial render:

const h1Element = useRef(null)                        // 1. initialize to null

useEffect(() => {
    h1Element.current.innerText = "New home page"     // 3. the element is then accessed via h1Element.current       
},[])

return (
    <h1 ref={h1Element}> Home page </h1>               // 2. when the component renders, h1Element.current will point to this HTML element. 
)

Note: that useEffect occurs AFTER react renders the JSX (the stuff in the return).
The order in which these line occurs are:
1) Ref const h1Element is create and points to null
2) the return is called and the h1 is appended to the DOM. after being appended, ref constant h1Element points to it. 
3) the useEffect is called, and changes the inner text of the h1

------------------ Creating the wrapper for our D3 class ------------------

We will be creating a D3 class in a separete JS file. Then exporting that class. The class will take in an HTML element that we pass it.
The element will be enacted on by D3 to attach our D3 visuals. W


1) create a separate javascript file called D3Chart.js

    1a) import all methods from d3 into a d3 object at the top of your code: 

        import * as d3 from 'd3'; 

    1b) create/export a class called D3Chart. 

        class D3Chart{
            constructor(element){
                const svg = d3.select(element)        // in here we will enact our D3 functionality on the element passed to us. 
                        .append('svg')
                          .attr('width', 500)
                          .attr('height', 500);
                        
                svg.append('circle')
                     .attr('r', 40)
                     .attr('cy', 100)
                     .attr('cx', 100)
                     .attr('fill', 'red');
            }
        }

2) create a new react component called ChartWrapper and pop that guy into App.jsx like we do with any other React component.

    2a) create a reference to an element in the component with useRef, then on initial render, instantiate a new D3Chart() object and pass in the reference to the HTML element:

    function ChartWrapper() {
        const chart = useRef(null);

        useEffect(() => {
            new D3Chart(chart.current);               // create instance of D3Chart and pass in the referenced element 
        }, []);

        return (
            <>
            <h1>ChartWrapper</h1>
            <div ref={chart}></div>                   // create reference to the element that will hold our D3Chart
            </>
        );
    }

------------------ D3 data joining------------------
Good blog post on data(), enter(), update(), and exit()
https://bost.ocks.org/mike/join/

import * as d3 from 'd3'

-- we will use the d3 object's methods to select an element, and bind data to it, then append SVG elements 
to those bound data points. This allows us to customize the SVG element and do animations on the elements 
depending on the data bound to it. 

-- When we bind data to an element, d3 will compare the data to the data already bound to the element. It allows us to manipulate
any new data that we are binding, matching data that is already there, and old data that is not in the new updated bound data. 

data = [1,2,3,4,5,6]              // sample data

let svg = d3.select(element)      // this will find an element on the DOM and return it.   
    .append('svg')                // then we will append an svg element to it. => returns the appended element
      .attr('width', 1000)        // these are setting attributes of the svg element => return the element with the updated attribute
      .attr('height', 1000);

let selection = svg.selectAll('rect') // 1. now we are searching for all existing <rect> elements within the SVG element => returns a d3 selection. 
                                     // If you ran this previously, there may be some previously data-bound rect elements, THATs the point. on first run this will return an empty selection
   .data(data);                      // 2. This takes in an ARRAY of data and BINDS it to the selection. this returns a 3 part selection. enter, update, and exit. this line specifically returns the update section
                                     // you can access the enter section by putting a .enter() same with exit(). 
                                     // enter represents the set of data that is new from the data you binded. 
                                     // update represent the set of data that you binded that already existed in the selection. 
                                     // exit represents the set of data that was already in the selection, but is not in the set of data you binded. 
                                     // its a venn diagram. you can alter each set of data seperately. => this returns the update() selection (bounded data that was already there that matches data you just binded)
    
selection.enter()                    // 3. we are now going to access the set of data that we binded that is all new. aka was not previously bound to the selection from line 1. => returns a selection 
   .append('rect')                   // 4. we are appending a rect svg element to each of the elements in the enter() selection. 
                                     // This will make rectangles appear on the screen representing all new data. => returns a selection of the newly added rect elements
     .attr('width', 50)              // 5. this will make all the of rect elements width 50 
     .attr('height', (d, i) => d)    // 6. this will dynamically set the height of each rect element based on the DATA POINT THAT IT IS BOUND TO. The second parameter can be a function, where 
                                     // the first parameter of the function is the data point that it is bound to. the second parameter is the data points index in the data array.
     .attr('x', (d, i) => 100 * i )  // 7. this will dynamically set the x coordinate offset of the svg element. aka it moves it right. every element will be 100 px to the right of the previous. 
     .attr('y', 20)                  // 8. this sets the y coordinate to 20 for all rect elements. 
     .attr('fill', 'green')          // set the color to green 

selection.exit()                     // 9. this is accessing the data exit selection aka the data that existed previously, but does not exist in the newly bound data. => returns a selection of already existing bound data 
   .remove()                         // 10. this will remove all of the old data from the svg. 

selection.update()                   // 11. this will access the data that already existed in the original selection THAT matches the data we bound to the selection. => returns a selection of elements that are already bound.
   .attr('fill', 'red')              // 12. this sets the color of the already existing elements to red.

-- essentially what we did was append a new set of data. all matching data that matches the newly bounds data turns red. any NEW data appears on the screen in green. and any already existing data that
does not match any point in the new data gets removed. 

------------------ D3 scales ------------------

-------- linear scale -- d3.scaleLinear(): this acts as a function (like y=mx+b) which takes in an input domain and converts it to an output range. 
To create the function we supply two things: 
1) a tuple array for the input domain
2) a tuple array for the output range. 
The linearScale() method will return a function that can take any number within the input domain and return to number scaled to the output domain. This is useful if we want to display a bar chart of people's 
heights, and we want to scale each bar to the max height of the bar chart. 

example: 
const y = d3.scaleLinear()
            .domain([0,300])        // the max range of heights that we will input to our chart if 282 cm.
            .range([0,500])         // but we want to scale the chart to 500 px.

console.log(y(150))                 // this will print 250. because 150 is half of 300 and scaled to 500 is 250. 

-- y acts as a formula or function that takes an input number (that is within the domain we set) and output thats number SCALED to the range that we provided. 
When we create our bar chart later, we use this to set the height of our bars when we append them to the page. 

const selection = d3.select(element)
              .append(svg)
              .attr('height', 500)                  // the height of the entire SVG is only 500 
              .attr('width', 500)
              .data(data)

selection.selectAll('rects')
         .enter()
         .append('rects')
         .attr('height', point => y(point.height))   // this way the bars are SCALED to the size of the SVG. if an input height comes in at 300 it will fill the entire height of the SVG. 
         .attr('width', 50)

-------- band scale -- d3.scaleBand(): this is a function that maps in input array of values to an output range. It returns a function that can take an input value (that must be in the input domain) and returns 
a number on in the output range scale. the output represents the start of the band that represents the value in the output range.

const x = d3.scaleBand()
            .domain(['a','b','c'])         // it basically takes the range 0 - 1000 and chops it into 3 bands (because there are 3 inputs). the first band is 'a', the second is 'b'...
            .range([0,1000])  

console.log(x('a'))                         // 0  
console.log(x('b'))                         // 333     it returns where the band for that input value starts on the range.
console.log(x('c'))                         // 666
console.log(x('d'))                         //undefined

-- you can add padding to it to make the bands look nicer: 

const x = d3.scaleBand()
            .domain(['a','b','c'])         
            .range([0,1000]) 
            .innerPadding(0.2)               // value from 0 to 1 that represents the space between each band. the scale is 0 to 1 STEPS which is from the start of one band to the start of the next
            .outerPadding(0.1)               // this will set the padding on the left and right of the starting and ending band

you can also just do padding(0.3) and it will set innerPadding and outerPadding to the same number 
 
-- When you use scaleBand, the width of the band will be calculated by the function that you created & other attributes like padding. To return this calculated value you can use bandwidth() method

x.bandwidth()       // will return the width of each band after applying your scale and padding and stuff.
x.scale()           // will return the distance between start of one band and the next. 

-------- note on how to specify domain 

When creating a scale, the input domain is based on the input data. 
For example in our linear scale, we specified the domain to be [0, 282]. We knew 282 is the height of the tallest person in the input data. But what if we don't know?

We need a way to find the max height or min height of the input data. D3 has a method for that. 

let max = d3.max(people, person => person.height)      // this is a method that takes 2 parms. the first is the input data array, the second is a function that returns the value to be compared
                                                       // this will return the max data_point.height in the data array.

let min = d3.min(grades, grade => grade.score)         // does the same but finds the minimum 

let minmax = d3.extent(people, person => person.age)  // this will return a TUPLE [18,75] which the first item is the minimum and the second is the max. 

-- it is common to use this in place of the domain variable 

let y = d3.scaleLinear()
          .domain[0, d3.max(data, p => p.height)]     // call it right in the domain funtion
          .range([0, height])

----

When inputting for a band scale, in which you need to input a set of values rather than a number tuple, it is recommended to use the map() function.
arr.map(p => p.height) iterates over every item in the array and returns a new array with only what is returned. 

for making bands, the input domain must be an array of values. so we can just call map when setting the domain variable:

let x = d3.scaleBand()
          .domain(data.map(point => point.name))     // call it right in the domain function. this will "name" every band that is created.
          .range([0, width])                         // use constants for your height and width to make it easily scalable.

------------------ Bars on the chart start at the top ------------------

the bars on the barchart seem to start at the top and grow downward...
-- the reason for this is that SVG 'rect's use the x and y attributes to determine location within the svg, except the x and y coordinates are the top left point of the rectangle.

To fix this we need to accomodate for this when we set our y attribute

d3.select('svg')
  .selectAll('rect')
  .data(data)
  .enter()
  .append('rect')
  .attr('x', point => x(point.name))
  .attr('y', point => height - y(point.height))     // we take the height (which can be variable), then minus the height of the bar - except we need to scale the height of the bar to the range first.
                                                    // this essentially will LOWER the top of the rectangle, and due to math the bottoms will align with the bottom of the SVG.
 